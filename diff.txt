diff --git a/Ct4.cpp b/Ct4.cpp
index 25ceb47..6d591f4 100644
--- a/Ct4.cpp
+++ b/Ct4.cpp
@@ -191,6 +191,36 @@ namespace tkz {
     Position Position::copy() {
         return Position(this->Filename, this->Filetxt, this->index, this->line, this->column);
     }
+    Position get_pos(const NumberVariant& v) {
+        return std::visit([](auto const& x) -> Position {
+            using T = std::decay_t<decltype(x)>;
+
+            if constexpr (std::is_same_v<T, Number<int>> ||
+                        std::is_same_v<T, Number<float>> ||
+                        std::is_same_v<T, Number<double>> ||
+                        std::is_same_v<T, Number<long long>> ||
+                        std::is_same_v<T, Number<short>> ||
+                        std::is_same_v<T, Number<long double>>) {
+                return x.pos;
+            } else if constexpr (std::is_same_v<T, StringValue> ||
+                                std::is_same_v<T, CharValue>   ||
+                                std::is_same_v<T, BoolValue>   ||
+                                std::is_same_v<T, QBoolValue>  ||
+                                std::is_same_v<T, VoidValue>   ||
+                                std::is_same_v<T, FunctionValue>) {
+                return x.pos;
+            } else if constexpr (std::is_same_v<T, std::shared_ptr<ArrayValue>>   ||
+                                std::is_same_v<T, std::shared_ptr<ListValue>>    ||
+                                std::is_same_v<T, std::shared_ptr<MapValue>>     ||
+                                std::is_same_v<T, std::shared_ptr<StructValue>>  ||
+                                std::is_same_v<T, std::shared_ptr<InstanceValue>>||
+                                std::is_same_v<T, std::shared_ptr<MultiValue>>) {
+                return x ? x->pos : Position();
+            } else {
+                return Position();
+            }
+        }, v);
+    }
     Token::Token() {}
     Token::Token(TokenType t, std::string val, Position p)
     : type(t), value(val), pos(p)
@@ -781,7 +811,7 @@ namespace tkz {
         
         if (this->current_tok.type != TokenType::LPAREN) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected '(' after 'qif'", this->current_tok.pos));
+                "QC-S001: Expected '(' after 'qif'", this->current_tok.pos));
             return res.to_prs();
         }
         this->advance();
@@ -794,14 +824,14 @@ namespace tkz {
 
         if (this->current_tok.type != TokenType::RPAREN) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected ')' after qif condition", this->current_tok.pos));
+                "QC-S002: Expected ')' after qif condition", this->current_tok.pos));
             return res.to_prs();
         }
         this->advance();
 
         if (this->current_tok.type != TokenType::LBRACE) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected '{' after qif condition", this->current_tok.pos));
+                "QC-S003: Expected '{' after qif condition", this->current_tok.pos));
             return res.to_prs();
         }
 
@@ -820,7 +850,7 @@ namespace tkz {
 
         if (this->current_tok.type != TokenType::RBRACE) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected '}'", this->current_tok.pos));
+                "QC-S004: Expected '}'", this->current_tok.pos));
             return res.to_prs();
         }
         this->advance();
@@ -836,7 +866,7 @@ namespace tkz {
             this->advance();
             if (this->current_tok.type != TokenType::LPAREN) {
                 res.failure(std::make_unique<InvalidSyntaxError>(
-                    "Expected '(' after 'qelif'", this->current_tok.pos));
+                    "QC-S005: Expected '(' after 'qelif'", this->current_tok.pos));
                 return res.to_prs();
             }
             this->advance();
@@ -846,14 +876,14 @@ namespace tkz {
             
             if (this->current_tok.type != TokenType::RPAREN) {
                 res.failure(std::make_unique<InvalidSyntaxError>(
-                    "Expected ')' after qelif condition", this->current_tok.pos));
+                    "QC-S006: Expected ')' after qelif condition", this->current_tok.pos));
                 return res.to_prs();
             }
             this->advance();
             
             if (this->current_tok.type != TokenType::LBRACE) {
                 res.failure(std::make_unique<InvalidSyntaxError>(
-                    "Expected '{' after qelif condition", this->current_tok.pos));
+                    "QC-S007: Expected '{' after qelif condition", this->current_tok.pos));
                 return res.to_prs();
             }
             
@@ -869,7 +899,7 @@ namespace tkz {
 
             if (this->current_tok.type != TokenType::RBRACE) {
                 res.failure(std::make_unique<InvalidSyntaxError>(
-                    "Expected '}'", this->current_tok.pos));
+                    "QC-S004: Expected '}'", this->current_tok.pos));
                 return res.to_prs();
             }
             this->advance();
@@ -885,7 +915,7 @@ namespace tkz {
             this->advance();
             if (this->current_tok.type != TokenType::LBRACE) {
                 res.failure(std::make_unique<InvalidSyntaxError>(
-                    "Expected '{' after 'qelse'", this->current_tok.pos));
+                    "QC-S008: Expected '{' after 'qelse'", this->current_tok.pos));
                 return res.to_prs();
             }
             
@@ -901,7 +931,7 @@ namespace tkz {
 
             if (this->current_tok.type != TokenType::RBRACE) {
                 res.failure(std::make_unique<InvalidSyntaxError>(
-                    "Expected '}'", this->current_tok.pos));
+                    "QC-S004: Expected '}'", this->current_tok.pos));
                 return res.to_prs();
             }
             this->advance();
@@ -937,13 +967,13 @@ namespace tkz {
         };
         ParseResult res;
         if (!(this->current_tok.type == TokenType::KEYWORD && this->current_tok.value == "if")) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected 'if'", this->current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S009: Expected 'if'", this->current_tok.pos));
             return res.to_prs();
         }
         this->advance(); 
 
         if (this->current_tok.type != TokenType::LPAREN) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected '(' after 'if'", this->current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S010: Expected '(' after 'if'", this->current_tok.pos));
             return res.to_prs();
         }
         this->advance();
@@ -969,7 +999,7 @@ namespace tkz {
                     this->advance();
                     tok = this->current_tok;
                     if (tok.type != TokenType::KEYWORD) {
-                        res.failure(std::make_unique<InvalidSyntaxError>("Expected type after 'const' in if-init", this->current_tok.pos));
+                        res.failure(std::make_unique<InvalidSyntaxError>("QC-S011: Expected type after 'const' in if-init", this->current_tok.pos));
                         return res.to_prs();
                     }
                 }
@@ -977,7 +1007,7 @@ namespace tkz {
                 this->advance();
 
                 if (this->current_tok.type != TokenType::IDENTIFIER) {
-                    res.failure(std::make_unique<InvalidSyntaxError>("Expected identifier in if-init", this->current_tok.pos));
+                    res.failure(std::make_unique<InvalidSyntaxError>("QC-S012: Expected identifier in if-init", this->current_tok.pos));
                     return res.to_prs();
                 }
                 Token var_name = this->current_tok;
@@ -990,14 +1020,14 @@ namespace tkz {
                     if (res.error) return res.to_prs();
                 } else {
                     if (is_const) {
-                        res.failure(std::make_unique<InvalidSyntaxError>("const variables must be initialized in if-init", var_name.pos));
+                        res.failure(std::make_unique<InvalidSyntaxError>("QC-S013: const variables must be initialized in if-init", var_name.pos));
                         return res.to_prs();
                     }
                     value = default_value_for_type(type_tok, var_name.pos);
                 }
 
                 if (this->current_tok.type != TokenType::SEMICOLON) {
-                    res.failure(std::make_unique<InvalidSyntaxError>("Expected ';' after if-init declaration", this->current_tok.pos));
+                    res.failure(std::make_unique<InvalidSyntaxError>("QC-S014: Expected ';' after if-init declaration", this->current_tok.pos));
                     return res.to_prs();
                 }
                 this->advance(); 
@@ -1008,7 +1038,7 @@ namespace tkz {
                 if (res.error) return res.to_prs();
 
                 if (this->current_tok.type != TokenType::SEMICOLON) {
-                    res.failure(std::make_unique<InvalidSyntaxError>("Expected ';' after if-init expression", this->current_tok.pos));
+                    res.failure(std::make_unique<InvalidSyntaxError>("QC-S015: Expected ';' after if-init expression", this->current_tok.pos));
                     return res.to_prs();
                 }
                 this->advance(); 
@@ -1020,7 +1050,7 @@ namespace tkz {
         if (res.error) return res.to_prs();
 
         if (this->current_tok.type != TokenType::RPAREN) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected ')' after condition", this->current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S016: Expected ')' after condition", this->current_tok.pos));
             return res.to_prs();
         }
         this->advance(); 
@@ -1038,14 +1068,14 @@ namespace tkz {
             if (this->current_tok.type == TokenType::KEYWORD && this->current_tok.value == "if") {
                 this->advance();
                 if (this->current_tok.type != TokenType::LPAREN) {
-                    res.failure(std::make_unique<InvalidSyntaxError>("Expected '(' after 'else if'", this->current_tok.pos));
+                    res.failure(std::make_unique<InvalidSyntaxError>("QC-S017: Expected '(' after 'else if'", this->current_tok.pos));
                     return res.to_prs();
                 }
                 this->advance();
                 AnyNode elif_cond = res.reg(this->logical_or());
                 if (res.error) return res.to_prs();
                 if (this->current_tok.type != TokenType::RPAREN) {
-                    res.failure(std::make_unique<InvalidSyntaxError>("Expected ')' after 'else if' condition", this->current_tok.pos));
+                    res.failure(std::make_unique<InvalidSyntaxError>("QC-S018: Expected ')' after 'else if' condition", this->current_tok.pos));
                     return res.to_prs();
                 }
                 this->advance();
@@ -1065,13 +1095,13 @@ namespace tkz {
     Prs Parser::switch_stmt() {
         ParseResult res;
         if (!(current_tok.type == TokenType::KEYWORD && current_tok.value == "switch")) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected 'switch'", current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S019: Expected 'switch'", current_tok.pos));
             return res.to_prs();
         }
         advance();
 
         if (current_tok.type != TokenType::LPAREN) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected '(' after 'switch'", current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S020: Expected '(' after 'switch'", current_tok.pos));
             return res.to_prs();
         }
         advance();
@@ -1080,13 +1110,13 @@ namespace tkz {
         if (res.error) return res.to_prs();
 
         if (current_tok.type != TokenType::RPAREN) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected ')' after switch expression", current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S021: Expected ')' after switch expression", current_tok.pos));
             return res.to_prs();
         }
         advance();
 
         if (current_tok.type != TokenType::LBRACE) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected '{' after switch(...)", current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S022: Expected '{' after switch(...)", current_tok.pos));
             return res.to_prs();
         }
         advance();
@@ -1115,7 +1145,7 @@ namespace tkz {
                     if (res.error) return res.to_prs();
 
                     if (current_tok.type != TokenType::COLON ) {
-                        res.failure(std::make_unique<InvalidSyntaxError>("Expected ':' after case expression", current_tok.pos));
+                        res.failure(std::make_unique<InvalidSyntaxError>("QC-S023: Expected ':' after case label", current_tok.pos));
                         return res.to_prs();
                     }
                     advance();
@@ -1125,7 +1155,7 @@ namespace tkz {
             }
 
             if (!saw_label) {
-                res.failure(std::make_unique<InvalidSyntaxError>("Expected 'case' or 'default' inside switch", current_tok.pos));
+                res.failure(std::make_unique<InvalidSyntaxError>("QC-S024: Expected 'case' or 'default' inside switch", current_tok.pos));
                 return res.to_prs();
             }
             std::vector<AnyNode> stmts;
@@ -1153,7 +1183,7 @@ namespace tkz {
         }
 
         if (current_tok.type != TokenType::RBRACE) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected '}' after switch body", current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S025: Expected '}' after switch body", current_tok.pos));
             return res.to_prs();
         }
         advance();
@@ -1169,7 +1199,7 @@ namespace tkz {
         
         if (this->current_tok.type != TokenType::LPAREN) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected '(' after 'qswitch'", this->current_tok.pos));
+                "QC-S026: Expected '(' after 'qswitch'", this->current_tok.pos));
             return res.to_prs();
         }
         this->advance();
@@ -1179,14 +1209,14 @@ namespace tkz {
         
         if (this->current_tok.type != TokenType::RPAREN) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected ')' after qswitch value", this->current_tok.pos));
+                "QC-S027: Expected ')' after qswitch value", this->current_tok.pos));
             return res.to_prs();
         }
         this->advance();
         
         if (this->current_tok.type != TokenType::LBRACE) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected '{' after qswitch", this->current_tok.pos));
+                "QC-S028: Expected '{' after qswitch", this->current_tok.pos));
             return res.to_prs();
         }
         this->advance();
@@ -1201,7 +1231,7 @@ namespace tkz {
             
             if (this->current_tok.type != TokenType::IDENTIFIER) {
                 res.failure(std::make_unique<InvalidSyntaxError>(
-                    "Expected case label (t, f, n, or b)", this->current_tok.pos));
+                    "QC-S029: Expected case label (t, f, n, or b)", this->current_tok.pos));
                 return res.to_prs();
             }
             
@@ -1210,7 +1240,7 @@ namespace tkz {
             
             if (this->current_tok.type != TokenType::COLON) {
                 res.failure(std::make_unique<InvalidSyntaxError>(
-                    "Expected ':' after case label", this->current_tok.pos));
+                    "QC-S023: Expected ':' after case label", this->current_tok.pos));
                 return res.to_prs();
             }
             this->advance();
@@ -1248,14 +1278,14 @@ namespace tkz {
                 case_b = std::move(case_body);
             } else {
                 res.failure(std::make_unique<InvalidSyntaxError>(
-                    "Invalid case label (must be t, f, n, or b)", this->current_tok.pos));
+                    "QC-S030: Invalid case label (must be t, f, n, or b)", this->current_tok.pos));
                 return res.to_prs();
             }
         }
         
         if (this->current_tok.type != TokenType::RBRACE) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected '}' after qswitch", this->current_tok.pos));
+                "QC-S031: Expected '}' after qswitch", this->current_tok.pos));
             return res.to_prs();
         }
         this->advance();
@@ -1270,13 +1300,13 @@ namespace tkz {
     Prs Parser::while_stmt() {
         ParseResult res;
         if (!(current_tok.type == TokenType::KEYWORD && current_tok.value == "while")) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected 'while'", current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S032: Expected 'while'", current_tok.pos));
             return res.to_prs();
         }
         advance();
 
         if (current_tok.type != TokenType::LPAREN) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected '(' after 'while'", current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S033: Expected '(' after 'while'", current_tok.pos));
             return res.to_prs();
         }
         advance();
@@ -1285,7 +1315,7 @@ namespace tkz {
         if (res.error) return res.to_prs();
 
         if (current_tok.type != TokenType::RPAREN) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected ')' after while condition", current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S034: Expected ')' after while condition", current_tok.pos));
             return res.to_prs();
         }
         advance();
@@ -1300,13 +1330,13 @@ namespace tkz {
         ParseResult res;
         Token type_tok;
         if (!(current_tok.type == TokenType::KEYWORD && current_tok.value == "for")) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected 'for'", current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S035: Expected 'for'", current_tok.pos));
             return res.to_prs();
         }
         advance();
 
         if (current_tok.type != TokenType::LPAREN) {
-            res.failure(std::make_unique<InvalidSyntaxError>("Expected '(' after 'for'", current_tok.pos));
+            res.failure(std::make_unique<InvalidSyntaxError>("QC-S036: Expected '(' after 'for'", current_tok.pos));
             return res.to_prs();
         }
         advance();
@@ -1334,7 +1364,7 @@ namespace tkz {
                     tok = current_tok;
                     if (tok.type != TokenType::KEYWORD) {
                         res.failure(std::make_unique<InvalidSyntaxError>(
-                            "Expected type after 'const' in for-init", current_tok.pos));
+                            "QC-S037: Expected type after 'const' in for-init", current_tok.pos));
                         return res.to_prs();
                     }
                 }
@@ -1344,7 +1374,7 @@ namespace tkz {
 
                 if (current_tok.type != TokenType::IDENTIFIER) {
                     res.failure(std::make_unique<InvalidSyntaxError>(
-                        "Expected identifier in for-init", current_tok.pos));
+                        "QC-S038: Expected identifier in for-init", current_tok.pos));
                     return res.to_prs();
                 }
 
@@ -1359,7 +1389,7 @@ namespace tkz {
                 } else {
                     if (is_const) {
                         res.failure(std::make_unique<InvalidSyntaxError>(
-                            "const variables must be initialized in for-init", var_name.pos));
+                            "QC-S039: const variables must be initialized in for-init", var_name.pos));
                         return res.to_prs();
                     }
                     value = default_value_for_type(type_tok, var_name.pos);
@@ -1377,7 +1407,7 @@ namespace tkz {
 
         if (current_tok.type != TokenType::SEMICOLON) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected ';' after for-init", current_tok.pos));
+                "QC-S040: Expected ';' after for-init", current_tok.pos));
             return res.to_prs();
         }
         advance();
@@ -1391,7 +1421,7 @@ namespace tkz {
 
         if (current_tok.type != TokenType::SEMICOLON) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected ';' after for condition", current_tok.pos));
+                "QC-S041: Expected ';' after for condition", current_tok.pos));
             return res.to_prs();
         }
         advance();
@@ -1404,7 +1434,7 @@ namespace tkz {
 
         if (current_tok.type != TokenType::RPAREN) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected ')' after for header", current_tok.pos));
+                "QC-S042: Expected ')' after for header", current_tok.pos));
             return res.to_prs();
         }
         advance();
@@ -1431,7 +1461,7 @@ namespace tkz {
                 }
                 if (this->current_tok.type != TokenType::RBRACE) {
                     res.failure(std::make_unique<InvalidSyntaxError>(
-                        "Expected '}' after for body", this->current_tok.pos));
+                        "QC-S043: Expected '}' after for body", this->current_tok.pos));
                     return false;
                 }
                 this->advance();
@@ -1505,7 +1535,7 @@ namespace tkz {
 
         if (this->current_tok.type != TokenType::RPAREN) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected ')' after function arguments", this->current_tok.pos));
+                "QC-S044: Expected ')' after function arguments", this->current_tok.pos));
             return res.to_prs();
         }
 
@@ -1572,7 +1602,7 @@ namespace tkz {
         
         if (this->current_tok.type != TokenType::RBRACKET) {
             res.failure(std::make_unique<InvalidSyntaxError>(
-                "Expected ']' in array literal", this->current_tok.pos));
+                "QC-S045: Expected ']' in array literal", this->current_tok.pos));
             return res.to_prs();
         }
         
@@ -1617,7 +1647,7 @@ namespace tkz {
 
                     if (this->current_tok.type != TokenType::COLON) {
                         res2.failure(std::make_unique<InvalidSyntaxError>(
-                            "Expected ':' in map literal", this->current_tok.pos));
+                            "QC-S046: Expected ':' in map literal", this->current_tok.pos));
                         return res2.to_prs();
                     }
                     this->advance();
@@ -1630,7 +1660,7 @@ namespace tkz {
 
                 if (this->current_tok.type != TokenType::RBRACE) {
                     res2.failure(std::make_unique<InvalidSyntaxError>(
-                        "Expected '}' at end of map literal", this->current_tok.pos));
+                        "QC-S047: Expected '}' at end of map literal", this->current_tok.pos));
                     return res2.to_prs();
                 }
                 this->advance();
@@ -1650,7 +1680,7 @@ namespace tkz {
 
                 if (this->current_tok.type != TokenType::RBRACE) {
                     res2.failure(std::make_unique<InvalidSyntaxError>(
-                        "Expected '}' in initializer list", this->current_tok.pos));
+                        "QC-S048: Expected '}' in initializer list", this->current_tok.pos));
                     return res2.to_prs();
                 }
                 this->advance();
@@ -1719,7 +1749,7 @@ namespace tkz {
 
                 if (this->current_tok.type != TokenType::IDENTIFIER) {
                     res.failure(std::make_unique<InvalidSyntaxError>(
-                        "Expected identifier after '::'", this->current_tok.pos));
+                        "QC-N001: Expected identifier or namespace name after '::'", this->current_tok.pos));
                     return res.to_prs();
                 }
 
@@ -1750,7 +1780,7 @@ namespace tkz {
 
                     if (this->current_tok.type != TokenType::RBRACKET) {
                         res.failure(std::make_unique<InvalidSyntaxError>(
-                            "Expected ']'", this->current_tok.pos));
+                            "QC-S049: Expected ']'", this->current_tok.pos));
                         return res.to_prs();
                     }
                     this->advance();
@@ -1799,7 +1829,7 @@ namespace tkz {
 
                     if (this->current_tok.type != TokenType::RPAREN) {
                         res.failure(std::make_unique<InvalidSyntaxError>(
-                            "Expected ')' after function arguments",
+                            "QC-S044: Expected ')' after function arguments",
                             this->current_tok.pos));
                         return res.to_prs();
                     }
@@ -1820,7 +1850,7 @@ namespace tkz {
                         if (res.error) return res.to_prs();
                         if (this->current_tok.type != TokenType::RBRACKET) {
                             res.failure(std::make_unique<InvalidSyntaxError>(
-                                "Expected ']'", this->current_tok.pos));
+                                "QC-S049: Expected ']'", this->current_tok.pos));
                             return res.to_prs();
                         }
                         this->advance();
@@ -3723,7 +3753,7 @@ namespace tkz {
                 this->advance();
                 if (this->current_tok.type != TokenType::RBRACKET) {
                     res.failure(std::make_unique<InvalidSyntaxError>(
-                        "Expected ']'", this->current_tok.pos));
+                        "QC-S049: Expected ']'", this->current_tok.pos));
                     return res.to_prs();
                 }
                 this->advance();
@@ -3833,7 +3863,7 @@ namespace tkz {
                 }
                 
                 if (this->current_tok.type != TokenType::RBRACKET) {
-                    res.failure(std::make_unique<InvalidSyntaxError>("Expected ']'", this->current_tok.pos));
+                    res.failure(std::make_unique<InvalidSyntaxError>("QC-S049: Expected ']'", this->current_tok.pos));
                     return res.to_prs();
                 }
                 this->advance();
@@ -4212,6 +4242,68 @@ namespace tkz {
         }
         return nullptr;
     }
+    ClassMethodInfo* Interpreter::find_method_overload_on_class(
+        const std::string& className,
+        const std::string& mname,
+        const std::vector<NumberVariant>& args
+    ) {
+        auto it = context->user_types.find(className);
+        if (it == context->user_types.end()) return nullptr;
+
+        UserTypeInfo* cur = &it->second;
+
+        std::vector<ClassMethodInfo*> candidates;
+        while (cur) {
+            for (auto& m : cur->classMethods) {
+                if (!m.is_constructor && m.name_tok.value == mname) {
+                    candidates.push_back(&m);
+                }
+            }
+
+            if (cur->baseClassName.empty()) break;
+            auto bit = context->user_types.find(cur->baseClassName);
+            if (bit == context->user_types.end() ||
+                bit->second.kind != UserTypeKind::Class) {
+                break;
+            }
+            cur = &bit->second;
+        }
+
+        if (candidates.empty()) return nullptr;
+
+        std::vector<ClassMethodInfo*> matches;
+        for (auto* m : candidates) {
+            if (m->params.size() == args.size()) {
+                matches.push_back(m);
+            }
+        }
+        if (matches.empty()) return nullptr;
+        if (matches.size() == 1) return matches[0];
+
+        auto get_type = [this](const NumberVariant& v) {
+            return this->context->get_type_name(v);
+        };
+
+        std::vector<ClassMethodInfo*> best;
+        for (auto* m : matches) {
+            bool all_ok = true;
+            size_t i = 0;
+            for (auto itp = m->params.begin(); itp != m->params.end(); ++itp, ++i) {
+                std::string expected = itp->type.value;
+                std::string actual   = get_type(args[i]);
+                if (expected != "auto" && expected != actual) {
+                    all_ok = false;
+                    break;
+                }
+            }
+            if (all_ok) best.push_back(m);
+        }
+
+        if (best.empty()) return nullptr;
+        if (best.size() == 1) return best[0];
+
+        return best[0];
+    }
     bool Interpreter::is_truthy(const NumberVariant& val) {
         return std::visit([this](auto&& v) -> bool {
             using T = std::decay_t<decltype(v)>;
@@ -4231,19 +4323,20 @@ namespace tkz {
                 auto inst = v;
                 const std::string& className = inst->class_name;
 
-                ClassMethodInfo* method = find_method_on_class(className, "eval");
+                std::vector<NumberVariant> no_args;
+                ClassMethodInfo* method = find_method_overload_on_class(className, "eval", no_args);
                 if (!method) {
                     this->errors.push_back({RTError(
                         "Instance of '" + className +
-                        "' used as condition but is missing eval(): defaulting true", Position()),
+                        "' used as condition but is missing eval(): defaulting true", get_pos(inst)),
                         "Warning"});
                     return true;
                 }
                 NumberVariant result = call_instance_method(
                     inst,
                     method,
-                    std::vector<NumberVariant>{},
-                    Position()
+                    no_args,
+                    get_pos(inst)
                 );
                 if (auto b = std::get_if<BoolValue>(&result)) {
                     return b->value;
@@ -4251,7 +4344,7 @@ namespace tkz {
 
                 this->errors.push_back({RTError(
                     "eval() on class '" + className + "' must return bool",
-                    Position()),
+                    get_pos(result)),
                     "Error"});
                 return false;
             }
@@ -4341,7 +4434,7 @@ namespace tkz {
             auto sym_it = it->find(qualify(name));
             if (sym_it != it->end()) {
                 if (sym_it->second.is_const) {
-                    throw RTError("Cannot assign to const variable '" + name + "'", pos);
+                    throw RTError("QC-T001: Cannot assign to const variable '" + name + "'", pos);
                 }
                 
                 std::string expected = sym_it->second.declared_type;
@@ -4388,7 +4481,7 @@ namespace tkz {
                     
                     if (!ok) {
                         throw RTError(
-                            "Type mismatch: value of type " + actual +
+                            "QC-T004: Type mismatch: value of type " + actual +
                             " is not assignable to union type '" + expected + "'",
                             pos
                         );
@@ -4404,7 +4497,7 @@ namespace tkz {
                 };
                 
                 if (get_base(expected) != get_base(actual) && expected != actual) {
-                    throw RTError("Type mismatch: cannot assign " + actual + " to " + expected, pos);
+                    throw RTError("QC-T003: Type mismatch: cannot assign " + actual + " to " + expected, pos);
                 }
                 
                 sym_it->second.value = std::move(new_val);
@@ -4417,7 +4510,7 @@ namespace tkz {
                 auto sym_it = it->find(name);
                 if (sym_it != it->end()) {
                     if (sym_it->second.is_const) {
-                        throw RTError("Cannot assign to const variable '" + name + "'", pos);
+                        throw RTError("QC-T001: Cannot assign to const variable '" + name + "'", pos);
                     }
                     
                     std::string expected = sym_it->second.declared_type;
@@ -4464,7 +4557,7 @@ namespace tkz {
                         
                         if (!ok) {
                             throw RTError(
-                                "Type mismatch: value of type " + actual +
+                                "QC-T004: Type mismatch: value of type " + actual +
                                 " is not assignable to union type '" + expected + "'",
                                 pos
                             );
@@ -4480,7 +4573,7 @@ namespace tkz {
                     };
                     
                     if (get_base(expected) != get_base(actual) && expected != actual) {
-                        throw RTError("Type mismatch: cannot assign " + actual + " to " + expected, pos);
+                        throw RTError("QC-T003: Type mismatch: cannot assign " + actual + " to " + expected, pos);
                     }
                     
                     sym_it->second.value = std::move(new_val);
@@ -4489,7 +4582,7 @@ namespace tkz {
             }
         }
         
-        throw RTError("Undefined variable: '" + name + "'", pos);
+        throw RTError("QC-C001: Undefined variable: '" + name + "'", pos);
     }
     NumberVariant def_value_for_type(const std::string& type_name) {
         if (type_name == "int") return Number<int>(0);
@@ -4524,20 +4617,20 @@ namespace tkz {
             else if constexpr (std::is_same_v<T, std::shared_ptr<InstanceValue>>) {
                 auto inst = v;
                 const std::string& className = inst->class_name;
-
-                ClassMethodInfo* method = find_method_on_class(className, "repr");
+                std::vector<NumberVariant> no_args;
+                ClassMethodInfo* method = find_method_overload_on_class(className, "repr", no_args);
                 if (!method) {
                     this->errors.push_back({RTError(
                         "Instance of '" + className +
-                        "' printed, but missing repr function: calling base print.", Position()),
+                        "' printed, but missing repr function: calling base print.", get_pos(inst)),
                         "Warning"});
                     return v->print();
                 }
                 NumberVariant result = call_instance_method(
                     inst,
                     method,
-                    std::vector<NumberVariant>{},
-                    Position()
+                    no_args,
+                    get_pos(inst)
                 );
                 if (auto s = std::get_if<StringValue>(&result)) {
                     return s->value;
@@ -4545,7 +4638,7 @@ namespace tkz {
 
                 this->errors.push_back({RTError(
                     "repr() on class '" + className + "' must return string",
-                    Position()),
+                    get_pos(result)),
                     "Error"});
                 return v->print();
             }
@@ -4818,7 +4911,7 @@ namespace tkz {
 
                 if (expectedKey != actualKey || expectedValue != actualValue) {
                     this->errors.push_back({RTError(
-                        "Type mismatch for map field '" + field.name +
+                        "QC-T010: Type mismatch for map field '" + field.name +
                         "': expected " + field.type +
                         ", got map<" + actualKey + "," + actualValue + ">",
                         {}
@@ -4959,7 +5052,7 @@ namespace tkz {
 
                             if (expectedKeyType != actualKeyType || expectedValType != actualValType) {
                                 this->errors.push_back({RTError(
-                                    "Type mismatch for map field '" + field.name +
+                                    "QC-T010: Type mismatch for map field '" + field.name +
                                     "': expected " + field.type +
                                     ", got map<" + actualKeyType + "," + actualValType + ">",
                                     node->var_name_tok.pos
@@ -4999,7 +5092,7 @@ namespace tkz {
 
                 if (!ok) {
                     this->errors.push_back({RTError(
-                        "Type mismatch: value of type " + valType +
+                        "QC-T004: Type mismatch: value of type " + valType +
                         " is not assignable to union type '" + node->type_tok.value + "'",
                         Position()
                     ), "Error"});
@@ -5063,7 +5156,7 @@ namespace tkz {
             }
             if (!type_matches) {
                 this->errors.push_back({RTError(
-                    "Type mismatch: expected " + declaredType + ", got " + actualType,
+                    "QC-T003: Type mismatch: expected " + declaredType + ", got " + actualType,
                     node->var_name_tok.pos
                 ), "Error"});
             }
@@ -5270,7 +5363,7 @@ namespace tkz {
             return ExecResult{std::move(last), false, false};
         }
         
-        this->errors.push_back({RTError("qswitch requires a qbool", Position()), "Severe"});
+        this->errors.push_back({RTError("qswitch requires a qbool", get_pos(val)), "Severe"});
         return {};
     }
     NumberVariant Interpreter::operator()(std::unique_ptr<QSwitchNode>& node) {
@@ -5442,7 +5535,7 @@ namespace tkz {
 
             for (auto& lbl : sec.cases) {
                 NumberVariant case_val = this->process(lbl.expr);
-                if (values_equal(switch_val, case_val, Position())) {
+                if (values_equal(switch_val, case_val, get_pos(case_val))) {
                     start_index = i;
                     break;
                 }
@@ -5508,13 +5601,13 @@ namespace tkz {
 
         NumberVariant target_val;
         std::string func_name = "<anonymous>";
-
+        std::vector<NumberVariant> final_args;
         if (std::holds_alternative<std::unique_ptr<VarAccessNode>>(node->node_to_call)) {
             auto& varacc = std::get<std::unique_ptr<VarAccessNode>>(node->node_to_call);
             func_name = varacc->var_name_tok.value;
             if (func_name == "throw") {
                 if (node->arg_nodes.size() != 1) {
-                    this->errors.push_back({RTError("throw() requires exactly 1 argument", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: throw() requires exactly 1 argument", get_pos(target_val)), "Error"});
                 }
                 
                 NumberVariant value = this->process(node->arg_nodes.front());
@@ -5525,7 +5618,7 @@ namespace tkz {
                         return v.print();
                     }
                 }, value);
-                throw RTError(msg, Position());
+                throw RTError(msg, get_pos(value));
             }
             if (func_name == "print" || func_name == "println") {
                 for (auto& arg : node->arg_nodes)
@@ -5551,7 +5644,7 @@ namespace tkz {
                         int r = rand() % max_num->value;
                         return Number<int>(r);
                     }
-                    this->errors.push_back({RTError("random(max) requires integer argument",  Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B002: random(max) requires integer argument",  get_pos(args[0])), "Error"});
                 }
                 else if (args.size() == 2) {
                     if (auto min_num = std::get_if<Number<int>>(&args[0])) {
@@ -5561,14 +5654,14 @@ namespace tkz {
                             return Number<int>(r);
                         }
                     }
-                    this->errors.push_back({RTError("random(min, max) requires integer arguments", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B002: random(min, max) requires integer arguments", get_pos(args[1])), "Error"});
                 }
                 
-                this->errors.push_back({RTError("random() takes 0, 1, or 2 arguments", Position()), "Error"});
+                this->errors.push_back({RTError("QC-B001: random() takes 0, 1, or 2 arguments", get_pos(args[2])), "Error"});
             }
             if (func_name == "time") {
                 if (node->arg_nodes.size() != 0) {
-                    this->errors.push_back({RTError("time() takes no arguments", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: time() takes no arguments", Position()), "Error"});
                 }
                 
                 return Number<int>(static_cast<int>(time(nullptr)));
@@ -5576,7 +5669,7 @@ namespace tkz {
             if (func_name == "seed") {
                 
                 if (node->arg_nodes.size() != 1) {
-                    this->errors.push_back({RTError("seed() requires exactly 1 argument", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: seed() requires exactly 1 argument", Position()), "Error"});
                 }
                 
                 NumberVariant seed_val = this->process(node->arg_nodes.front());
@@ -5587,12 +5680,12 @@ namespace tkz {
                     return VoidValue();
                 }
                 
-                this->errors.push_back({RTError("seed() requires integer argument",  Position()), "Error"});
+                this->errors.push_back({RTError("QC-B002: seed() requires integer argument",  get_pos(seed_val)), "Error"});
             }
             if (func_name == "typeof") {
                 
                 if (node->arg_nodes.size() != 1) {
-                    this->errors.push_back({RTError("typeof() requires exactly 1 argument", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: typeof() requires exactly 1 argument", Position()), "Error"});
                 }
                 
                 NumberVariant value = this->process(node->arg_nodes.front());
@@ -5601,7 +5694,7 @@ namespace tkz {
             }
             if (func_name == "to_qbool") {
                 if (node->arg_nodes.size() != 1) {
-                    this->errors.push_back({RTError("to_qbool() requires exactly 1 argument", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: to_qbool() requires exactly 1 argument", Position()), "Error"});
                 }
 
                 NumberVariant cur_val = this->process(node->arg_nodes.front());
@@ -5616,20 +5709,20 @@ namespace tkz {
                         return QBoolValue(sv->value).set_pos(sv->pos);
                     }
                     this->errors.push_back({RTError(
-                        "to_qbool() requires string argument to be qtrue qfalse both or none.",
+                        "QC-B002: to_qbool() requires string argument to be qtrue qfalse both or none.",
                         sv->pos),
                         "Error"});
                 } else {
                     this->errors.push_back({RTError(
-                        "to_qbool() requires string or boolean argument",
-                        Position()),
+                        "QC-B002: to_qbool() requires string or boolean argument",
+                        get_pos(cur_val)),
                         "Error"});
                 }
             }
 
             if (func_name == "to_bool") {
                 if (node->arg_nodes.size() != 1) {
-                    this->errors.push_back({RTError("to_bool() requires exactly 1 argument", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: to_bool() requires exactly 1 argument", Position()), "Error"});
                 }
 
                 NumberVariant cur_val = this->process(node->arg_nodes.front());
@@ -5643,20 +5736,20 @@ namespace tkz {
                         return BoolValue(sv->value).set_pos(sv->pos);
                     }
                     this->errors.push_back({RTError(
-                        "to_bool() requires string argument to be true or false.",
+                        "QC-B002: to_bool() requires string argument to be true or false.",
                         sv->pos),
                         "Error"});
                 } else {
                     this->errors.push_back({RTError(
-                        "to_bool() requires string or quantum boolean argument",
-                        Position()),
+                        "QC-B002: to_bool() requires string or quantum boolean argument",
+                        get_pos(cur_val)),
                         "Error"});
                 }
             }
 
             if (func_name == "to_int") {
                 if (node->arg_nodes.size() != 1) {
-                    this->errors.push_back({RTError("to_int() requires exactly 1 argument", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: to_int() requires exactly 1 argument", Position()), "Error"});
                 }
 
                 NumberVariant cur_val = this->process(node->arg_nodes.front());
@@ -5672,7 +5765,7 @@ namespace tkz {
                         return Number<int>(std::stoi(sv->value)).set_pos(sv->pos);
                     } catch (...) {
                         this->errors.push_back({RTError(
-                            "could not convert value to int.",
+                            "QC-B002: could not convert value to int.",
                             sv->pos),
                             "Error"});
                     }
@@ -5682,22 +5775,22 @@ namespace tkz {
                     else if (qbv->valname == "qfalse") val = 1;
                     else if (qbv->valname == "qtrue")  val = 2;
                     else if (qbv->valname == "both")   val = 3;
-                    else throw RTError("What the heck is that", qbv->pos);
+                    else throw RTError("QC-WHAT: What the heck is that", qbv->pos);
 
                     return Number<int>(val).set_pos(qbv->pos);
                 } else if (auto bv = std::get_if<BoolValue>(&cur_val)) {
                     return Number<int>(bv->value ? 1 : 0).set_pos(bv->pos);
                 } else {
                     this->errors.push_back({RTError(
-                        "to_int() cannot take that argument type.",
-                        Position()),
+                        "QC-B002: to_int() cannot take that argument type.",
+                        get_pos(cur_val)),
                         "Error"});
                 }
             }
 
             if (func_name == "to_float") {
                 if (node->arg_nodes.size() != 1) {
-                    this->errors.push_back({RTError("to_float() requires exactly 1 argument", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: to_float() requires exactly 1 argument", Position()), "Error"});
                 }
 
                 NumberVariant cur_val = this->process(node->arg_nodes.front());
@@ -5713,21 +5806,21 @@ namespace tkz {
                         return Number<float>(std::stof(sv->value)).set_pos(sv->pos);
                     } catch (...) {
                         this->errors.push_back({RTError(
-                            "could not convert value to float.",
+                            "QC-B002: could not convert value to float.",
                             sv->pos),
                             "Error"});
                     }
                 } else {
                     this->errors.push_back({RTError(
-                        "to_float() cannot take that argument type.",
-                        Position()),
+                        "QC-B002: to_float() cannot take that argument type.",
+                        get_pos(cur_val)),
                         "Error"});
                 }
             }
 
             if (func_name == "to_double") {
                 if (node->arg_nodes.size() != 1) {
-                    this->errors.push_back({RTError("to_double() requires exactly 1 argument", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: to_double() requires exactly 1 argument", Position()), "Error"});
                 }
 
                 NumberVariant cur_val = this->process(node->arg_nodes.front());
@@ -5743,21 +5836,21 @@ namespace tkz {
                         return Number<double>(std::stod(sv->value)).set_pos(sv->pos);
                     } catch (...) {
                         this->errors.push_back({RTError(
-                            "could not convert value to double.",
+                            "QC-B002: could not convert value to double.",
                             sv->pos),
                             "Error"});
                     }
                 } else {
                     this->errors.push_back({RTError(
-                        "to_double() cannot take that argument type.",
-                        Position()),
+                        "QC-B002: to_double() cannot take that argument type.",
+                        get_pos(cur_val)),
                         "Error"});
                 }
             }
 
             if (func_name == "to_char") {
                 if (node->arg_nodes.size() != 1) {
-                    this->errors.push_back({RTError("to_char() requires exactly 1 argument", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: to_char() requires exactly 1 argument", Position()), "Error"});
                 }
 
                 NumberVariant cur_val = this->process(node->arg_nodes.front());
@@ -5767,21 +5860,21 @@ namespace tkz {
                         return CharValue(std::string(1, sv->value[0])).set_pos(sv->pos);
                     }
                     this->errors.push_back({RTError(
-                        "to_char() cannot take empty string.",
+                        "QC-B002: to_char() cannot take empty string.",
                         sv->pos),
                         "Error"});
                 } else if (auto cv = std::get_if<CharValue>(&cur_val)) {
                     return *cv;
                 } else {
                     this->errors.push_back({RTError(
-                        "to_char() cannot take that argument type.",
-                        Position()),
+                        "QC-B002: to_char() cannot take that argument type.",
+                        get_pos(cur_val)),
                         "Error"});
                 }
             }
             if (func_name == "to_string") {
                 if (node->arg_nodes.size() != 1) {
-                    this->errors.push_back({RTError("to_string() requires exactly 1 argument", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-B001: to_string() requires exactly 1 argument", Position()), "Error"});
                 }
 
                 NumberVariant cur_val = this->process(node->arg_nodes.front());
@@ -5800,8 +5893,8 @@ namespace tkz {
                     return StringValue(bv->value ? "true" : "false").set_pos(bv->pos);
                 } else {
                     this->errors.push_back({RTError(
-                        "to_string() cannot take that argument type.",
-                        Position()),
+                        "QC-B002: to_string() cannot take that argument type.",
+                        get_pos(cur_val)),
                         "Error"});
                 }
             }
@@ -5813,7 +5906,7 @@ namespace tkz {
                 bool inside_constructor = false;
                 std::shared_ptr<InstanceValue> existing_inst = nullptr;
                 if (info.is_abstract_class) {
-                    errors.push_back({RTError("Cannot construct abstract class", Position()), "Error"});
+                    errors.push_back({RTError("QC-B002: Cannot construct abstract class", Position()), "Error"});
                     return VoidValue();
                 }
                 try {
@@ -5841,7 +5934,7 @@ namespace tkz {
                         if (!ctor) {
                             return VoidValue();
                         }
-                        std::vector<NumberVariant> final_args;
+                        final_args.clear();
                         for (auto& arg : node->arg_nodes) {
                             if (auto spread = std::get_if<std::unique_ptr<SpreadNode>>(&arg)) {
                                 NumberVariant sv = this->process((*spread)->expr);
@@ -5850,7 +5943,7 @@ namespace tkz {
                                 } else if (auto lst = std::get_if<std::shared_ptr<ListValue>>(&sv)) {
                                     for (auto& e : (*lst)->elements) final_args.push_back(e);
                                 } else {
-                                    this->errors.push_back({RTError("Spread target must be array or list", Position()), "Error"});
+                                    this->errors.push_back({RTError("QC-I005: Spread target must be array or list", get_pos(sv)), "Error"});
                                 }
                             } else {
                                 final_args.push_back(this->process(arg));
@@ -5860,7 +5953,7 @@ namespace tkz {
 
                         if (final_args.size() > ctor->params.size()) {
                             context->pop_scope();
-                            this->errors.push_back({RTError("Too many arguments to parent constructor '" + func_name + "'", Position()), "Error"});
+                            this->errors.push_back({RTError("QC-C002: Too many arguments to parent constructor '" + func_name + "'", Position()), "Error"});
                             return VoidValue();
                         }
 
@@ -5875,7 +5968,7 @@ namespace tkz {
                                 value = this->process(it_param->default_value.value());
                             } else {
                                 context->pop_scope();
-                                this->errors.push_back({RTError("Missing argument to parent constructor '" + func_name + "'", Position()), "Error"});
+                                this->errors.push_back({RTError("QC-C004: Missing argument to parent constructor '" + func_name + "'", get_pos(value)), "Error"});
                                 return VoidValue();
                             }
                             context->define(it_param->name.value, it_param->type.value, value);
@@ -5895,7 +5988,6 @@ namespace tkz {
                 }
                 auto fields = make_instance_fields(func_name);
                 auto inst = std::make_shared<InstanceValue>(func_name, std::move(fields));
-
                 ClassMethodInfo* ctor = nullptr;
                 for (auto& m : info.classMethods) {
                     if (m.is_constructor) {
@@ -5903,12 +5995,16 @@ namespace tkz {
                         break;
                     }
                 }
-
+                std::vector<NumberVariant> no_args;
+                ClassMethodInfo* init_m = this->find_method_overload_on_class(func_name, "init", no_args);
                 if (!ctor) {
+                    if (init_m) {
+                        this->call_instance_method(inst, init_m, no_args, Position{});
+                    }
                     return inst;
                 }
 
-                std::vector<NumberVariant> final_args;
+                final_args.clear();
                 for (auto& arg : node->arg_nodes) {
                     if (auto spread = std::get_if<std::unique_ptr<SpreadNode>>(&arg)) {
                         NumberVariant sv = this->process((*spread)->expr);
@@ -5917,7 +6013,7 @@ namespace tkz {
                         } else if (auto lst = std::get_if<std::shared_ptr<ListValue>>(&sv)) {
                             for (auto& e : (*lst)->elements) final_args.push_back(e);
                         } else {
-                            this->errors.push_back({RTError("Spread target must be array or list", Position()), "Error"});
+                            this->errors.push_back({RTError("QC-I005: Spread target must be array or list", get_pos(sv)), "Error"});
                         }
                     } else {
                         final_args.push_back(this->process(arg));
@@ -5929,7 +6025,7 @@ namespace tkz {
 
                 if (final_args.size() > ctor->params.size()) {
                     context->pop_scope();
-                    this->errors.push_back({RTError("Too many arguments to constructor '" + func_name + "'", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-C002: Too many arguments to constructor '" + func_name + "'", Position()), "Error"});
                     return inst;
                 }
 
@@ -5944,7 +6040,7 @@ namespace tkz {
                         value = this->process(it_param->default_value.value());
                     } else {
                         context->pop_scope();
-                        this->errors.push_back({RTError("Missing argument to constructor '" + func_name + "'", Position()), "Error"});
+                        this->errors.push_back({RTError("QC-C004: Missing argument to constructor '" + func_name + "'", get_pos(value)), "Error"});
                         return inst;
                     }
                     context->define(it_param->name.value, it_param->type.value, value);
@@ -5961,36 +6057,62 @@ namespace tkz {
 
                 return inst;
             }
+            for (auto& arg : node->arg_nodes) {
+                if (auto spread = std::get_if<std::unique_ptr<SpreadNode>>(&arg)) {
+                    NumberVariant spread_val = this->process((*spread)->expr);
+
+                    if (auto arr = std::get_if<std::shared_ptr<ArrayValue>>(&spread_val)) {
+                        for (auto& elem : (*arr)->elements)
+                            final_args.push_back(elem);
+                    }
+                    else if (auto list = std::get_if<std::shared_ptr<ListValue>>(&spread_val)) {
+                        for (auto& elem : (*list)->elements)
+                            final_args.push_back(elem);
+                    }
+                    else {
+                        this->errors.push_back({RTError("QC-I005: Spread target must be array or list", get_pos(spread_val)), "Error"});
+                    }
+                }
+                else {
+                    final_args.push_back(this->process(arg));
+                }
+            }
+
             std::string lookup_name = func_name;
+            std::shared_ptr<FuncDefNode> fn = nullptr;
+
             if (lookup_name.find("::") != std::string::npos) {
-                auto func = context->functions.find(lookup_name);
-                if (func != context->functions.end()) {
-                    target_val = FunctionValue(func->second);
-                } else {
-                    throw RTError("Undefined function: '" + func_name + "'", Position());
+                fn = context->get_function_overload(lookup_name, final_args);
+                if (fn) {
+                    target_val = FunctionValue(fn);
                 }
             } else {
-                try { 
-                    target_val = context->get(func_name, varacc->var_name_tok.pos); 
+                try {
+                    target_val = context->get(func_name, varacc->var_name_tok.pos);
+                    if (std::holds_alternative<FunctionValue>(target_val)) {
+                    } else {
+                        throw RTError("Cannot call non-function value", varacc->var_name_tok.pos);
+                    }
                 } catch (RTError&) {
-                    auto func = context->get_function(func_name);
-                    if (!func) throw RTError("Undefined function: '" + func_name + "'", Position());
-                    target_val = FunctionValue(func);
+                    fn = context->get_function_overload(func_name, final_args);
+                    if (fn) {
+                        target_val = FunctionValue(fn);
+                    } else {
+                        throw RTError("Undefined function: " + func_name, varacc->var_name_tok.pos);
+                    }
                 }
             }
         } else {
             target_val = this->process(node->node_to_call);
         }
-        
         if (!std::holds_alternative<FunctionValue>(target_val))
-            this->errors.push_back({RTError("Can only call functions", Position()), "Error"});
+            throw RTError("Can only call functions", Position("", "", 0, 0, 0));
 
         FunctionValue fval = std::get<FunctionValue>(target_val);
-        if (!fval.func) this->errors.push_back({RTError("Invalid function value", Position()), "Error"});
+        if (!fval.func) this->errors.push_back({RTError("Invalid function value", fval.pos), "Error"});
 
         auto func = fval.func;
-        std::vector<NumberVariant> final_args;
-
+        final_args.clear();
         for (auto& arg : node->arg_nodes) {
 
             if (auto spread = std::get_if<std::unique_ptr<SpreadNode>>(&arg)) {
@@ -6005,7 +6127,7 @@ namespace tkz {
                         final_args.push_back(elem);
                 }
                 else {
-                    this->errors.push_back({RTError("Spread target must be array or list", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-I005: Spread target must be array or list", get_pos(spread_val)), "Error"});
                 }
             }
             else {
@@ -6041,7 +6163,7 @@ namespace tkz {
                 if (changed_namespace) {
                     context->namespaceStack = saved_namespace_stack;
                 }
-                this->errors.push_back({RTError("Too many arguments", Position()), "Error"});
+                this->errors.push_back({RTError("QC-C001: Too many arguments", Position()), "Error"});
             }
             for (size_t i = 0; i < func->params.size(); i++) {
                 NumberVariant value;
@@ -6054,7 +6176,7 @@ namespace tkz {
                 else if (it_param->default_value.has_value()) {
                     value = this->process(it_param->default_value.value());
                 }
-                else this->errors.push_back({RTError("Missing argument", Position()), "Error"});
+                else this->errors.push_back({RTError("QC-C003: Missing argument", Position()), "Error"});
 
                 
                 std::string expected_type = it_param->type.value;
@@ -6070,7 +6192,30 @@ namespace tkz {
                     if (expected_type == actual_type) {
                         types_compatible = true;
                     } else {
-                        auto ut_it = context->user_types.find(expected_type);
+                        std::string lookup_type = expected_type;
+                        auto ut_it = context->user_types.find(lookup_type);
+                        if (ut_it == context->user_types.end()) {
+                            size_t last_colon = lookup_type.rfind("::");
+                            if (last_colon == std::string::npos && !context->namespaceStack.empty()) {
+                                std::string qualified;
+                                for (auto& ns : context->namespaceStack) {
+                                    if (!qualified.empty()) qualified += "::";
+                                    qualified += ns;
+                                }
+                                lookup_type = qualified + "::" + expected_type;
+                                ut_it = context->user_types.find(lookup_type);
+                            }
+                        }
+                        if (ut_it == context->user_types.end()) {
+                            for (auto& [type_name, info] : context->user_types) {
+                                if (type_name == expected_type ||
+                                    type_name.rfind("::" + expected_type) != std::string::npos) {
+                                    ut_it = context->user_types.find(type_name);
+                                    break;
+                                }
+                            }
+                        }
+
                         if (ut_it != context->user_types.end() &&
                             ut_it->second.kind == UserTypeKind::Union) {
 
@@ -6087,16 +6232,16 @@ namespace tkz {
 
                             if (!ok) {
                                 this->errors.push_back({RTError(
-                                    "Type mismatch: value of type " + valType +
+                                    "QC-T004: Type mismatch: value of type " + valType +
                                     " is not assignable to union type '" + expected_type + "'",
                                     Position()
                                 ), "Error"});
                             }
 
                             actual_type = expected_type;
+                            types_compatible = true;
                         }
                     }
-
                     if (!types_compatible) {
                         if (expected_type.find("list<") != std::string::npos && actual_type.find("list<") != std::string::npos) {
                             std::string expected_base = expected_type;
@@ -6287,7 +6432,7 @@ namespace tkz {
                     return sym_it->second.value;
                 }
             }
-            throw RTError("Undefined variable: '" + name + "'", node->var_name_tok.pos);
+            throw RTError("QC-C001: Undefined variable: '" + name + "'", node->var_name_tok.pos);
         }
         
         auto result = context->get(name, node->var_name_tok.pos);
@@ -6364,7 +6509,7 @@ namespace tkz {
         if (args.size() > method->params.size()) {
             context->pop_scope();
             this->errors.push_back({RTError(
-                "Too many arguments to method '" + mname + "'",
+                "QC-C002: Too many arguments to method '" + mname + "'",
                 pos),
                 "Error"});
             return VoidValue{};
@@ -6382,7 +6527,7 @@ namespace tkz {
             } else {
                 context->pop_scope();
                 this->errors.push_back({RTError(
-                    "Missing argument " + it_param->name.value +
+                    "QC-C004: Missing argument " + it_param->name.value +
                     " for method '" + mname + "'",
                     pos),
                     "Error"});
@@ -6512,23 +6657,22 @@ namespace tkz {
         
         if (node->op_tok.type == TokenType::AND) {
             NumberVariant left = std::move(this->process(node->left_node));
-            
+            NumberVariant right = std::move(this->process(node->right_node));
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&left)) {
-                ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, "operator&&");
+                std::vector<NumberVariant> arrvr = {right};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator&&", {arrvr});
                 if (method) {
-                    NumberVariant right = std::move(this->process(node->right_node));
-                    return call_instance_method(*inst_ptr, method, {right}, node->op_tok.pos);
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             
             if (!is_truthy(left)) return BoolValue("false");
             
-            NumberVariant right = std::move(this->process(node->right_node));
-            
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&right)) {
-                ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, "operator&&");
+                std::vector<NumberVariant> arrvr = {left};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator&&", arrvr);
                 if (method) {
-                    return call_instance_method(*inst_ptr, method, {left}, node->op_tok.pos);
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             
@@ -6537,23 +6681,22 @@ namespace tkz {
 
         if (node->op_tok.type == TokenType::OR) {
             NumberVariant left = std::move(this->process(node->left_node));
-            
+            NumberVariant right = std::move(this->process(node->right_node));
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&left)) {
-                ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, "operator||");
+                std::vector<NumberVariant> arrvr = {right};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator||", {arrvr});
                 if (method) {
-                    NumberVariant right = std::move(this->process(node->right_node));
-                    return call_instance_method(*inst_ptr, method, {right}, node->op_tok.pos);
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             
-            if (is_truthy(left)) return BoolValue("true");
-            
-            NumberVariant right = std::move(this->process(node->right_node));
+            if (!is_truthy(left)) return BoolValue("false");
             
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&right)) {
-                ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, "operator||");
+                std::vector<NumberVariant> arrvr = {left};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator||", arrvr);
                 if (method) {
-                    return call_instance_method(*inst_ptr, method, {left}, node->op_tok.pos);
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             
@@ -6565,16 +6708,20 @@ namespace tkz {
             NumberVariant right = std::move(this->process(node->right_node));
             
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&left)) {
-                ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, "operator^");
+                std::vector<NumberVariant> arrvr = {right};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator^", {arrvr});
                 if (method) {
-                    return call_instance_method(*inst_ptr, method, {right}, node->op_tok.pos);
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             
+            if (!is_truthy(left)) return BoolValue("false");
+            
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&right)) {
-                ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, "operator^");
+                std::vector<NumberVariant> arrvr = {left};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator^", arrvr);
                 if (method) {
-                    return call_instance_method(*inst_ptr, method, {left}, node->op_tok.pos);
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             
@@ -6586,33 +6733,18 @@ namespace tkz {
             NumberVariant left = this->process(node->left_node);
             NumberVariant right = this->process(node->right_node);
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&left)) {
-                std::string mname = "operator&&&";
-                if (!mname.empty()) {
-                    ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
-                    if (method) {
-                        NumberVariant result = call_instance_method(
-                            *inst_ptr,
-                            method,
-                            std::vector<NumberVariant>{ right },
-                            node->op_tok.pos
-                        );
-                        return result;
-                    }
+                std::vector<NumberVariant> arrvr = {right};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator&&&", {arrvr});
+                if (method) {
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
+            
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&right)) {
-                std::string mname = "operator&&&";
-                if (!mname.empty()) {
-                    ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
-                    if (method) {
-                        NumberVariant result = call_instance_method(
-                            *inst_ptr,
-                            method,
-                            std::vector<NumberVariant>{ left },
-                            node->op_tok.pos
-                        );
-                        return result;
-                    }
+                std::vector<NumberVariant> arrvr = {left};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator&&&", arrvr);
+                if (method) {
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             auto l_qb = std::get_if<QBoolValue>(&left);
@@ -6633,33 +6765,18 @@ namespace tkz {
             NumberVariant left = this->process(node->left_node);
             NumberVariant right = this->process(node->right_node);
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&left)) {
-                std::string mname = "operator|||";
-                if (!mname.empty()) {
-                    ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
-                    if (method) {
-                        NumberVariant result = call_instance_method(
-                            *inst_ptr,
-                            method,
-                            std::vector<NumberVariant>{ right },
-                            node->op_tok.pos
-                        );
-                        return result;
-                    }
+                std::vector<NumberVariant> arrvr = {right};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator|||", {arrvr});
+                if (method) {
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
+            
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&right)) {
-                std::string mname = "operator|||";
-                if (!mname.empty()) {
-                    ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
-                    if (method) {
-                        NumberVariant result = call_instance_method(
-                            *inst_ptr,
-                            method,
-                            std::vector<NumberVariant>{ left },
-                            node->op_tok.pos
-                        );
-                        return result;
-                    }
+                std::vector<NumberVariant> arrvr = {left};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator|||", arrvr);
+                if (method) {
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             auto l_qb = std::get_if<QBoolValue>(&left);
@@ -6681,33 +6798,18 @@ namespace tkz {
             NumberVariant left = this->process(node->left_node);
             NumberVariant right = this->process(node->right_node);
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&left)) {
-                std::string mname = "operator^^";
-                if (!mname.empty()) {
-                    ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
-                    if (method) {
-                        NumberVariant result = call_instance_method(
-                            *inst_ptr,
-                            method,
-                            std::vector<NumberVariant>{ right },
-                            node->op_tok.pos
-                        );
-                        return result;
-                    }
+                std::vector<NumberVariant> arrvr = {right};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator^^", {arrvr});
+                if (method) {
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
+            
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&right)) {
-                std::string mname = "operator^^";
-                if (!mname.empty()) {
-                    ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
-                    if (method) {
-                        NumberVariant result = call_instance_method(
-                            *inst_ptr,
-                            method,
-                            std::vector<NumberVariant>{ left },
-                            node->op_tok.pos
-                        );
-                        return result;
-                    }
+                std::vector<NumberVariant> arrvr = {left};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator^^", arrvr);
+                if (method) {
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             auto l_qb = std::get_if<QBoolValue>(&left);
@@ -6756,18 +6858,18 @@ namespace tkz {
             NumberVariant left = this->process(node->left_node);
             NumberVariant right = this->process(node->right_node);
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&left)) {
-                std::string mname = "operator&|&";
-                if (!mname.empty()) {
-                    ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
-                    if (method) {
-                        NumberVariant result = call_instance_method(
-                            *inst_ptr,
-                            method,
-                            std::vector<NumberVariant>{ right },
-                            node->op_tok.pos
-                        );
-                        return result;
-                    }
+                std::vector<NumberVariant> arrvr = {right};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator&|&", {arrvr});
+                if (method) {
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
+                }
+            }
+            
+            if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&right)) {
+                std::vector<NumberVariant> arrvr = {left};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator&|&", arrvr);
+                if (method) {
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             auto l_qb = std::get_if<QBoolValue>(&left);
@@ -6785,18 +6887,18 @@ namespace tkz {
             NumberVariant left = this->process(node->left_node);
             NumberVariant right = this->process(node->right_node);
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&left)) {
-                std::string mname = "operator|&|";
-                if (!mname.empty()) {
-                    ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
-                    if (method) {
-                        NumberVariant result = call_instance_method(
-                            *inst_ptr,
-                            method,
-                            std::vector<NumberVariant>{ right },
-                            node->op_tok.pos
-                        );
-                        return result;
-                    }
+                std::vector<NumberVariant> arrvr = {right};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator|&|", {arrvr});
+                if (method) {
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
+                }
+            }
+            
+            if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&right)) {
+                std::vector<NumberVariant> arrvr = {left};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, "operator|&|", arrvr);
+                if (method) {
+                    return call_instance_method(*inst_ptr, method, arrvr, node->op_tok.pos);
                 }
             }
             auto l_qb = std::get_if<QBoolValue>(&left);
@@ -6814,12 +6916,29 @@ namespace tkz {
         if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&left)) {
             std::string mname = op_method_name(node->op_tok.type);
             if (!mname.empty()) {
-                ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
+                std::vector<NumberVariant> arrvr = {right};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, mname, arrvr);
                 if (method) {
                     NumberVariant result = call_instance_method(
                         *inst_ptr,
                         method,
-                        std::vector<NumberVariant>{ right },
+                        arrvr,
+                        node->op_tok.pos
+                    );
+                    return result;
+                }
+            }
+        }
+        if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&right)) {
+            std::string mname = op_method_name(node->op_tok.type);
+            if (!mname.empty()) {
+                std::vector<NumberVariant> arrvr = {left};
+                ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, mname, arrvr);
+                if (method) {
+                    NumberVariant result = call_instance_method(
+                        *inst_ptr,
+                        method,
+                        arrvr,
                         node->op_tok.pos
                     );
                     return result;
@@ -6831,7 +6950,7 @@ namespace tkz {
             using T2 = std::decay_t<decltype(R)>;
 
             if (node->is_f) {
-                auto to_string_variant = [](auto const& v) -> std::string {
+                auto to_string_variant = [this](auto const& v) -> std::string {
                     using T = std::decay_t<decltype(v)>;
 
                     if constexpr (std::is_same_v<T, Number<int>> ||
@@ -6850,9 +6969,35 @@ namespace tkz {
                         return "<void>";
                     } else if constexpr (std::is_same_v<T, std::shared_ptr<ArrayValue>> ||
                                         std::is_same_v<T, std::shared_ptr<ListValue>> ||
-                                        std::is_same_v<T, std::shared_ptr<MultiValue>> ||
-                                        std::is_same_v<T, std::shared_ptr<InstanceValue>>) {
+                                        std::is_same_v<T, std::shared_ptr<MultiValue>>) {
                         return v ? v->print() : "<null>";
+                    } else if constexpr (std::is_same_v<T, std::shared_ptr<InstanceValue>>) {
+                        auto inst = v;
+                        const std::string& className = inst->class_name;
+                        std::vector<NumberVariant> no_args;
+                        ClassMethodInfo* method = find_method_overload_on_class(className, "repr", no_args);
+                        if (!method) {
+                            this->errors.push_back({RTError(
+                                "Instance of '" + className +
+                                "' printed, but missing repr function: calling base print.", Position()),
+                                "Warning"});
+                            return v->print();
+                        }
+                        NumberVariant result = call_instance_method(
+                            inst,
+                            method,
+                            no_args,
+                            Position()
+                        );
+                        if (auto s = std::get_if<StringValue>(&result)) {
+                            return s->value;
+                        }
+
+                        this->errors.push_back({RTError(
+                            "repr() on class '" + className + "' must return string",
+                            Position()),
+                            "Error"});
+                        return v->print();
                     } else {
                         return "<unknown>";
                     }
@@ -6989,7 +7134,7 @@ namespace tkz {
                 auto sym_it = it->find(name);
                 if (sym_it != it->end()) {
                     if (sym_it->second.is_const) {
-                        throw RTError("Cannot assign to const variable '" + name + "'", node->var_name.pos);
+                        throw RTError("QC-T001: Cannot assign to const variable '" + name + "'", node->var_name.pos);
                     }
                     if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&sym_it->second.value)) {
                         std::cerr << "AssignExprNode found class wiht qualification" << '\n';
@@ -7063,7 +7208,7 @@ namespace tkz {
                         
                         if (!ok) {
                             throw RTError(
-                                "Type mismatch: value of type " + actual_type +
+                                "QC-T004: Type mismatch: value of type " + actual_type +
                                 " is not assignable to union type '" + declared_type + "'",
                                 node->var_name.pos
                             );
@@ -7081,7 +7226,7 @@ namespace tkz {
                     if (get_base(declared_type) != get_base(actual_type) && 
                         declared_type != actual_type) {
                         throw RTError(
-                            "Type mismatch: cannot assign " + actual_type + " to " + declared_type,
+                            "QC-T003: Type mismatch: cannot assign " + actual_type + " to " + declared_type,
                             node->var_name.pos
                         );
                     } // Need to make operrator = work
@@ -7090,7 +7235,7 @@ namespace tkz {
                     return value;
                 }
             }
-            throw RTError("Undefined variable: '" + name + "'", node->var_name.pos);
+            throw RTError("QC-C001: Undefined variable: '" + name + "'", node->var_name.pos);
         }
         try {
             NumberVariant existing = context->get(name, node->var_name.pos);
@@ -7135,7 +7280,7 @@ namespace tkz {
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&val)) {
                 std::string mname = "operator!!";
                 if (!mname.empty()) {
-                    ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
+                    ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, mname, {});
                     if (method) {
                         NumberVariant result = call_instance_method(
                             *inst_ptr,
@@ -7177,7 +7322,7 @@ namespace tkz {
             if (auto inst_ptr = std::get_if<std::shared_ptr<InstanceValue>>(&val)) {
                 std::string mname = "operator!";
                 if (!mname.empty()) {
-                    ClassMethodInfo* method = find_method_on_class((*inst_ptr)->class_name, mname);
+                    ClassMethodInfo* method = find_method_overload_on_class((*inst_ptr)->class_name, mname, {});
                     if (method) {
                         NumberVariant result = call_instance_method(
                             *inst_ptr,
@@ -7551,7 +7696,7 @@ namespace tkz {
         bool is_list  = std::holds_alternative<std::shared_ptr<ListValue>>(base_value);
 
         if (!is_array && !is_list)
-            this->errors.push_back({RTError("Cannot index non-array/list type", Position()), "Error"});
+            this->errors.push_back({RTError("QC-I003: Cannot index non-array/list type", Position()), "Error"});
 
         std::shared_ptr<ArrayValue> current_array;
         std::shared_ptr<ListValue>  current_list;
@@ -7572,7 +7717,7 @@ namespace tkz {
 
             if (current_array) {
                 if (index < 0 || (size_t)index >= current_array->size())
-                    throw RTError("Array index out of bounds: " + std::to_string(index), Position());
+                    throw RTError("QC-I001: Array index out of bounds: " + std::to_string(index), Position());
                 NumberVariant next = current_array->elements[index];
 
                 if (dim == node->indices.size() - 1)
@@ -7585,11 +7730,11 @@ namespace tkz {
                     current_list = *next_list;
                     current_array.reset();
                 } else {
-                    this->errors.push_back({RTError("Cannot index inside non-array/list", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-I003: Cannot index inside non-array/list", Position()), "Error"});
                 }
             } else if (current_list) {
                 if (index < 0 || (size_t)index >= current_list->elements.size())
-                    throw RTError("List index out of bounds: " + std::to_string(index), Position());
+                    throw RTError("QC-I002: List index out of bounds: " + std::to_string(index), Position());
                 NumberVariant next = current_list->elements[index];
 
                 if (dim == node->indices.size() - 1)
@@ -7602,7 +7747,7 @@ namespace tkz {
                     current_list = *next_list;
                     current_array.reset();
                 } else {
-                    this->errors.push_back({RTError("Cannot index inside non-array/list", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-I003: Cannot index inside non-array/list", Position()), "Error"});
                 }
             } else {
                 this->errors.push_back({RTError("Internal error: lost array/list during indexing", Position()), "Error"});
@@ -7655,7 +7800,7 @@ namespace tkz {
                         final_args.push_back(elem);
                 }
                 else {
-                    this->errors.push_back({RTError("Spread target must be array or list", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-I005: Spread target must be array or list", Position()), "Error"});
                 }
             }
             else {
@@ -7669,7 +7814,7 @@ namespace tkz {
             if (mname == "has") {
                 if (node->args.size() != 1) {
                     this->errors.push_back({RTError(
-                        "class.has() expects 1 argument (field name)", node->method_name.pos),
+                        "QC-BM01: class.has() expects 1 argument (field name)", node->method_name.pos),
                         "Error"});
                     return BoolValue("false");
                 }
@@ -7677,7 +7822,7 @@ namespace tkz {
                 NumberVariant arg = this->process(node->args[0]);
                 if (!std::holds_alternative<StringValue>(arg)) {
                     this->errors.push_back({RTError(
-                        "class.has() argument must be a string", node->method_name.pos),
+                        "QC-BM02: class.has() argument must be a string", node->method_name.pos),
                         "Error"});
                     return BoolValue("false");
                 }
@@ -7690,7 +7835,7 @@ namespace tkz {
             if (mname == "has_method") {
                 if (node->args.size() != 1) {
                     this->errors.push_back({RTError(
-                        "class.has_method() expects 1 argument (method name)", node->method_name.pos),
+                        "QC-BM01: class.has_method() expects 1 argument (method name)", node->method_name.pos),
                         "Error"});
                     return BoolValue("false");
                 }
@@ -7698,7 +7843,7 @@ namespace tkz {
                 NumberVariant arg = this->process(node->args[0]);
                 if (!std::holds_alternative<StringValue>(arg)) {
                     this->errors.push_back({RTError(
-                        "class.has_method() argument must be a string", node->method_name.pos),
+                        "QC-BM02: class.has_method() argument must be a string", node->method_name.pos),
                         "Error"});
                     return BoolValue("false");
                 }
@@ -7718,10 +7863,10 @@ namespace tkz {
                 
                 return BoolValue("false");
             }
-            ClassMethodInfo* method = find_method_on_class(className, mname);
+            ClassMethodInfo* method = find_method_overload_on_class(className, mname, final_args);
             if (!method) {
                 this->errors.push_back({RTError(
-                    "Class '" + className + "' has no method '" + mname + "'",
+                    "QC-M001: Class '" + className + "' has no method '" + mname + "'",
                     node->method_name.pos),
                     "Error"});
                 return VoidValue{};
@@ -7732,7 +7877,7 @@ namespace tkz {
             if (node->method_name.value == "has") {
                 if (node->args.size() != 1) {
                     this->errors.push_back({RTError(
-                        "struct.has() expects 1 argument (field name)", node->method_name.pos),
+                        "QC-BM01: struct.has() expects 1 argument (field name)", node->method_name.pos),
                         "Error"});
                     return BoolValue("false");
                 }
@@ -7740,7 +7885,7 @@ namespace tkz {
                 NumberVariant arg = this->process(node->args[0]);
                 if (!std::holds_alternative<StringValue>(arg)) {
                     this->errors.push_back({RTError(
-                        "struct.has() argument must be a string", node->method_name.pos),
+                        "QC-BM02: struct.has() argument must be a string", node->method_name.pos),
                         "Error"});
                     return BoolValue("false");
                 }
@@ -7755,14 +7900,14 @@ namespace tkz {
             
             if (node->method_name.value == "push") {
                 if (node->args.size() != 1) {
-                    this->errors.push_back({RTError("push() requires exactly 1 argument", node->method_name.pos), "Error"});
+                    this->errors.push_back({RTError("QC-BM01: push() requires exactly 1 argument", node->method_name.pos), "Error"});
                 }
                 NumberVariant val = final_args[0];
                 std::string name = context->get_type_name(val);
                 if (name.find(strip(list->element_type)) == std::string::npos && !loose) {
-                    this->errors.push_back({RTError("cannot push a " + name + " to a list of type " + list->element_type, node->method_name.pos), "Error"});
+                    this->errors.push_back({RTError("QC-BM02: cannot push a " + name + " to a list of type " + list->element_type, node->method_name.pos), "Error"});
                 } else if (name != strip(list->element_type) && name.find("list<") == std::string::npos && name.find("[]") == std::string::npos) {
-                    this->errors.push_back({RTError("(loose) cannot push a " + name + " to a list of type " + list->element_type, node->method_name.pos), "Error"});
+                    this->errors.push_back({RTError("QC-BM02: (loose) cannot push a " + name + " to a list of type " + list->element_type, node->method_name.pos), "Error"});
                 }
                 list->push(std::move(val));
                 return VoidValue();
@@ -7770,19 +7915,19 @@ namespace tkz {
             
             if (node->method_name.value == "pop") {
                 if (node->args.size() != 0) {
-                    this->errors.push_back({RTError("pop() takes no arguments", node->method_name.pos), "Error"});
+                    this->errors.push_back({RTError("QC-BM01: pop() takes no arguments", node->method_name.pos), "Error"});
                 }
                 return list->pop();
             }
             
-            this->errors.push_back({RTError("Unknown method: " + node->method_name.value, node->method_name.pos), "Error"});
+            this->errors.push_back({RTError("QC-M001: Unknown method: " + node->method_name.value, node->method_name.pos), "Error"});
         }
         if (auto map_ptr = std::get_if<std::shared_ptr<MapValue>>(&obj)) {
             auto map = *map_ptr;
             
             if (node->method_name.value == "set") {
                 if (node->args.size() != 2) {
-                    this->errors.push_back({RTError("set() requires 2 arguments (key, value)", node->method_name.pos), "Error"});
+                    this->errors.push_back({RTError("QC-BM01: set() requires 2 arguments (key, value)", node->method_name.pos), "Error"});
                 }
                 NumberVariant key = this->process(node->args[0]);
                 NumberVariant val = this->process(node->args[1]);
@@ -7794,7 +7939,7 @@ namespace tkz {
             
             if (node->method_name.value == "remove") {
                 if (node->args.size() != 1) {
-                    this->errors.push_back({RTError("remove() requires 1 argument (key)", node->method_name.pos), "Error"});
+                    this->errors.push_back({RTError("QC-BM01: remove() requires 1 argument (key)", node->method_name.pos), "Error"});
                 }
                 NumberVariant key = this->process(node->args[0]);
                 std::string key_str = this->value_to_string(key);
@@ -7805,7 +7950,7 @@ namespace tkz {
             
             if (node->method_name.value == "has") {
                 if (node->args.size() != 1) {
-                    this->errors.push_back({RTError("has() requires 1 argument (key)", node->method_name.pos), "Error"});
+                    this->errors.push_back({RTError("QC-BM01: has() requires 1 argument (key)", node->method_name.pos), "Error"});
                 }
                 NumberVariant key = this->process(node->args[0]);
                 std::string key_str = this->value_to_string(key);
@@ -7815,7 +7960,7 @@ namespace tkz {
             
             if (node->method_name.value == "keys") {
                 if (node->args.size() != 0) {
-                    this->errors.push_back({RTError("keys() takes no arguments", node->method_name.pos), "Error"});
+                    this->errors.push_back({RTError("QC-BM01: keys() takes no arguments", node->method_name.pos), "Error"});
                 }
                 
                 auto keys = map->keys();
@@ -7827,9 +7972,9 @@ namespace tkz {
                 return std::make_shared<ArrayValue>("string", std::move(key_variants));
             }
             
-            this->errors.push_back({RTError("Unknown map method: " + node->method_name.value, node->method_name.pos), "Error"});
+            this->errors.push_back({RTError("QC-BM04: Unknown map method: " + node->method_name.value, node->method_name.pos), "Error"});
         }
-        this->errors.push_back({RTError("Object does not support methods", node->method_name.pos), "Error"});
+        this->errors.push_back({RTError("QC-BM05: Object does not support methods", node->method_name.pos), "Error"});
         return VoidValue();
     }
     NumberVariant make_value_from_type_atom(const std::string& atom) {
@@ -7916,7 +8061,7 @@ namespace tkz {
                         }
                     }
                     this->errors.push_back({RTError(
-                        "Enum '" + baseName + "' has no member '" + memberName + "'",
+                        "QC-F001: Enum '" + baseName + "' has no member '" + memberName + "'",
                         node->property_name.pos
                     ), "Error"});
                 }
@@ -7930,7 +8075,7 @@ namespace tkz {
             if (auto s = std::get_if<std::shared_ptr<StructValue>>(&obj)) {
                 auto it = (*s)->fields.find(name);
                 if (it == (*s)->fields.end()) {
-                    this->errors.push_back({RTError("Unknown field '" + name + "' on struct '" + (*s)->type_name + "'",
+                    this->errors.push_back({RTError("QC-F001: Unknown field '" + name + "' on struct '" + (*s)->type_name + "'",
                                 node->property_name.pos), "Error"});
                 }
                 obj = it->second;
@@ -7949,7 +8094,7 @@ namespace tkz {
                         if (fields[i].name == name) { idx = i; break; }
                     }
                     if (idx == SIZE_MAX) {
-                        this->errors.push_back({RTError("Unknown field '" + name + "' on struct '" + struct_type + "'",
+                        this->errors.push_back({RTError("QC-F001: Unknown field '" + name + "' on struct '" + struct_type + "'",
                                     node->property_name.pos), "Error"});
                     }
                     obj = (*arr)->elements[idx];
@@ -7971,7 +8116,7 @@ namespace tkz {
 
                 if (!field_exists_on_class(className, name)) {
                     this->errors.push_back({RTError(
-                        "Unknown field '" + name + "' on class '" + className + "'",
+                        "QC-F001: Unknown field '" + name + "' on class '" + className + "'",
                         node->property_name.pos),
                         "Error"});
                     return VoidValue{};
@@ -7980,7 +8125,7 @@ namespace tkz {
                 auto it = (*inst)->fields.find(name);
                 if (it == (*inst)->fields.end()) {
                     this->errors.push_back({RTError(
-                        "Internal error: field '" + name + "' missing on instance of '" + className + "'",
+                        "QC-X001: Internal error: field '" + name + "' missing on instance of '" + className + "'",
                         node->property_name.pos),
                         "Severe"});
                     return VoidValue{};
@@ -8003,7 +8148,7 @@ namespace tkz {
                     if (access == "private") {
                         if (!in_class_context(className)) {
                             this->errors.push_back({RTError(
-                                "Field '" + name + "' of class '" + className +
+                                "QC-A001: Field '" + name + "' of class '" + className +
                                 "' is " + access + " and cannot be accessed here",
                                 node->property_name.pos),
                                 "Error"});
@@ -8013,7 +8158,7 @@ namespace tkz {
                     if (access == "protected") {
                         if (!in_class_or_derived_context(className)) {
                             this->errors.push_back({RTError(
-                                "Field '" + name + "' of class '" + className +
+                                "QC-A001: Field '" + name + "' of class '" + className +
                                 "' is " + access + " and cannot be accessed here",
                                 node->property_name.pos),
                                 "Error"});
@@ -8025,7 +8170,7 @@ namespace tkz {
                 obj = it->second;
                 break;
             }
-            this->errors.push_back({RTError("Unknown property: " + name, node->property_name.pos), "Error"});
+            this->errors.push_back({RTError("QC-F002: Unknown property: " + name, node->property_name.pos), "Error"});
         }
 
         return obj;
@@ -8105,7 +8250,7 @@ namespace tkz {
             }
             
             if (flat_index < 0 || flat_index >= arr->elements.size()) {
-                this->errors.push_back({RTError("Array index out of bounds", Position()), "Error"});
+                this->errors.push_back({RTError("QC-I001: Array index out of bounds", Position()), "Error"});
             }
             
             arr->elements[flat_index] = std::move(val);
@@ -8125,7 +8270,7 @@ namespace tkz {
                 int idx = idx_num->value;
                 
                 if (idx < 0 || idx >= list->elements.size()) {
-                    this->errors.push_back({RTError("List index out of bounds", Position()), "Error"});
+                    this->errors.push_back({RTError("QC-I002: List index out of bounds", Position()), "Error"});
                 }
                 
                 list->elements[idx] = std::move(val);
@@ -8634,7 +8779,7 @@ namespace tkz {
 
             
             // Call main
-            std::shared_ptr<FuncDefNode> main_func = ctx->get_function("main");
+            std::shared_ptr<FuncDefNode> main_func = ctx->get_function_overload("main");
             if (!main_func) {
                 throw RTError("No main() function found", Position());
             }
diff --git a/docs/change.md b/docs/change.md
index c6a982e..24f3edd 100644
--- a/docs/change.md
+++ b/docs/change.md
@@ -10,7 +10,7 @@
 NAMESPCACES!!!!!!!!!!
 # Features checklist (suitable for change(by adding more))
 
-- [ ] User Types (
+- [x] User Types (
     - [x] Structs
     - [x] Enums
     - [x] Unions
diff --git a/qc b/qc
index 64d1463..d617216 100755
Binary files a/qc and b/qc differ
diff --git a/stdlib.qc b/stdlib.qc
index 86fedac..7c4f76c 100644
--- a/stdlib.qc
+++ b/stdlib.qc
@@ -80,4 +80,43 @@ namespace Utils {
         }
         return [@fin];
     }
+}
+namespace Math {
+    type Number = int | float | double;
+    Number max(Number a, Number b) {
+        if (a > b) {
+            return a;
+        }
+        if (a == b) {
+            return 0;
+        }
+        return b;
+    }
+    Number min(Number a, Number b) {
+        if (a > b) {
+            return b;
+        }
+        if (a == b) {
+            return 0;
+        }
+        return a;
+    }
+    Number sqrt(Number val) {
+        return to_double(val) ** 0.5;
+    }
+    Number root(Number val, Number power) {
+        return to_double(val) ** 1 / power;
+    }
+    type Floating = float | double;
+    int ceil(Floating a) {
+        double d = to_double(a);
+        int i = to_int(d);
+        if (d == i) {
+            return i;
+        } else if (d > 0) {
+            return i + 1;
+        } else {
+            return i;
+        }
+    }
 }
\ No newline at end of file
diff --git a/teststd.qc b/teststd.qc
index 07c4b60..a587553 100644
--- a/teststd.qc
+++ b/teststd.qc
@@ -1,6 +1,7 @@
 namespace Exported {
     #include <AdvQBool, std>
     #include <Utils, std>
+    #include <Math, std>
 }
 int main() {
     AdvQBool::AQB test = AdvQBool::AQB(70);
@@ -32,5 +33,9 @@ int main() {
     foreach (int i in Utils::range(1, 10, 1)) {
         std::qout << i << '\n';
     }
+    std::qout << Math::ceil(0.5) << '\n';
+    std::qout << Math::sqrt(4) << '\n';
+    std::qout << Math::root(27, 3) << '\n';
+    std::qout << Math::max(100, 1) << '\n' << Math::min(100, 1) << '\n';
     return 0;
 }
\ No newline at end of file
diff --git a/tokenizer.h b/tokenizer.h
index eff641d..c74624d 100644
--- a/tokenizer.h
+++ b/tokenizer.h
@@ -1309,10 +1309,13 @@ namespace tkz {
         public:
         std::string class_name;
         std::unordered_map<std::string, NumberVariant> fields;
+        Position pos;
         InstanceValue(std::string class_name, std::unordered_map<std::string, NumberVariant> fields) {
             this->class_name = class_name;
             this->fields = fields;
-        }InstanceValue(std::string class_name) {
+            this->pos = Position("", "", 0, 0, 0);
+        }
+        InstanceValue(std::string class_name) {
             this->class_name = class_name;
         }
         std::string print() const;
@@ -1320,8 +1323,8 @@ namespace tkz {
     class MultiValue {
     public:
         std::vector<NumberVariant> values;
-        
-        MultiValue(std::vector<NumberVariant>&& vals) : values(std::move(vals)) {}
+        Position pos;
+        MultiValue(std::vector<NumberVariant>&& vals) : values(std::move(vals)), pos("", "", 0, 0, 0) {}
         
         std::string print() const;
     };
@@ -1330,9 +1333,9 @@ namespace tkz {
         std::string element_type;
         std::vector<NumberVariant> elements;
         std::vector<std::vector<size_t>> nested_sizes;
-
+        Position pos;
         ArrayValue(std::string type, std::vector<NumberVariant> elems)
-            : element_type(type), elements(std::move(elems))
+            : element_type(type), elements(std::move(elems)), pos("", "", 0, 0, 0)
         {
             nested_sizes.resize(elements.size());
             for (size_t i = 0; i < elements.size(); i++) {
@@ -1355,9 +1358,9 @@ namespace tkz {
     public:
         std::string element_type;
         std::vector<NumberVariant> elements;
-        
+        Position pos;
         ListValue(std::string type, std::vector<NumberVariant> elems)
-            : element_type(type), elements(std::move(elems)) {}
+            : element_type(type), elements(std::move(elems)), pos("", "", 0, 0, 0) {}
         
         void push(NumberVariant val) {
             elements.push_back(std::move(val));
@@ -1514,7 +1517,7 @@ namespace tkz {
         public:
         std::vector<std::string> namespaceStack;
         std::vector<std::unordered_map<std::string, Symbol>> frames;
-        std::unordered_map<std::string, std::shared_ptr<FuncDefNode>> functions;
+        std::unordered_map<std::string, std::vector<std::shared_ptr<FuncDefNode>>> functions;
         void push_namespace(const std::string& name) {
             namespaceStack.push_back(name);
         }
@@ -1604,19 +1607,245 @@ namespace tkz {
             throw RTError("Undefined variable: '" + name + "'", pos);
         }
         void define_function(const std::string& name, std::shared_ptr<FuncDefNode> func) {
-            functions[qualify(name)] = std::move(func);
+            functions[qualify(name)].push_back(std::move(func));
         }
         
-        std::shared_ptr<FuncDefNode> get_function(const std::string& name) {
-            if (name.find("::") != std::string::npos) {
-                auto it = functions.find(name);
-                if (it != functions.end()) return it->second;
-                return nullptr;
+        std::vector<std::shared_ptr<FuncDefNode>> get_all_function_overloads(
+            const std::string& name
+        ) {
+            std::vector<std::shared_ptr<FuncDefNode>> candidates;
+            std::string qualified = qualify(name);
+            auto it = functions.find(qualified);
+            if (it != functions.end()) {
+                for (auto& fn : it->second) {
+                    candidates.push_back(fn);
+                }
+            }
+            if (!namespaceStack.empty()) {
+                auto it2 = functions.find(name);
+                if (it2 != functions.end()) {
+                    for (auto& fn : it2->second) {
+                        candidates.push_back(fn);
+                    }
+                }
+            }
+            
+            return candidates;
+        }
+        std::shared_ptr<FuncDefNode> get_best_function_overload(
+            const std::string& name,
+            const std::vector<NumberVariant>& args
+        ) {
+            auto candidates = get_all_function_overloads(name);
+            if (candidates.empty()) return nullptr;
+            std::vector<std::shared_ptr<FuncDefNode>> viable;
+            for (auto& fn : candidates) {
+                size_t min_params = 0;
+                for (auto& p : fn->params) {
+                    if (!p.default_value.has_value()) min_params++;
+                }
+                if (args.size() >= min_params && args.size() <= fn->params.size()) {
+                    viable.push_back(fn);
+                }
+            }
+            
+            if (viable.empty()) return nullptr;
+            if (viable.size() == 1) return viable[0];
+            std::shared_ptr<FuncDefNode> best = nullptr;
+            int best_score = -1;
+            
+            for (auto& fn : viable) {
+                int score = 0;
+                size_t i = 0;
+                bool valid = true;
+                
+                for (auto it = fn->params.begin(); it != fn->params.end(); ++it, ++i) {
+                    if (i >= args.size()) break;
+                    
+                    std::string expected = it->type.value;
+                    std::string actual = get_type_name(args[i]);
+                    
+                    if (expected == actual) {
+                        score += 100;
+                    } else if (expected == "auto") {
+                        score += 50;
+                    } else if (types_compatible(expected, actual)) {
+                        score += 25;
+                    } else {
+                        valid = false;
+                        break;
+                    }
+                }
+                
+                if (valid && score > best_score) {
+                    best_score = score;
+                    best = fn;
+                }
+            }
+            
+            return best;
+        }
+        std::shared_ptr<FuncDefNode> get_function_overload(
+            const std::string& name,
+            const std::vector<NumberVariant>& args = {}
+        ) {
+            return get_best_function_overload(name, args);
+        }
+        bool types_compatible(const std::string& expected_type, const std::string& actual_type) {
+            if (expected_type == actual_type) {
+                return true;
+            }
+            if (expected_type == "auto") {
+                return true;
+            }
+            if (expected_type == "double") {
+                if (actual_type == "float" || actual_type == "int" || 
+                    actual_type == "short int") {
+                    return true;
+                }
+            }
+            if (expected_type == "float") {
+                if (actual_type == "int" || actual_type == "short int") {
+                    return true;
+                }
+            }
+            if (expected_type == "long int") {
+                if (actual_type == "int" || actual_type == "short int") {
+                    return true;
+                }
+            }
+            if (expected_type == "long double") {
+                if (actual_type == "double" || actual_type == "float" || 
+                    actual_type == "int" || actual_type == "short int") {
+                    return true;
+                }
+            }
+            if (expected_type == "int" && actual_type == "short int") {
+                return true;
+            }
+
+            if (expected_type.find("list<") == 0 && actual_type.find("list<") == 0) {
+                size_t exp_start = expected_type.find('<') + 1;
+                size_t exp_end = expected_type.find('>');
+                size_t act_start = actual_type.find('<') + 1;
+                size_t act_end = actual_type.find('>');
+                
+                if (exp_end != std::string::npos && act_end != std::string::npos) {
+                    std::string exp_elem = expected_type.substr(exp_start, exp_end - exp_start);
+                    std::string act_elem = actual_type.substr(act_start, act_end - act_start);
+                    return types_compatible(exp_elem, act_elem);
+                }
+            }
+            if (expected_type.find("[]") != std::string::npos && 
+                actual_type.find("[]") != std::string::npos) {
+                size_t exp_bracket = expected_type.find("[]");
+                size_t act_bracket = actual_type.find("[]");
+                
+                std::string exp_base = expected_type.substr(0, exp_bracket);
+                std::string act_base = actual_type.substr(0, act_bracket);
+                return types_compatible(exp_base, act_base);
+            }
+            if (expected_type.find("map<") == 0 && actual_type.find("map<") == 0) {
+                auto extract_map_types = [](const std::string& map_type) 
+                    -> std::pair<std::string, std::string> {
+                    
+                    size_t start = map_type.find('<') + 1;
+                    size_t end = map_type.rfind('>');
+                    
+                    if (start == std::string::npos || end == std::string::npos) {
+                        return {"", ""};
+                    }
+                    
+                    std::string inner = map_type.substr(start, end - start);
+                    int depth = 0;
+                    size_t comma_pos = std::string::npos;
+                    
+                    for (size_t i = 0; i < inner.size(); ++i) {
+                        if (inner[i] == '<') depth++;
+                        else if (inner[i] == '>') depth--;
+                        else if (inner[i] == ',' && depth == 0) {
+                            comma_pos = i;
+                            break;
+                        }
+                    }
+                    
+                    if (comma_pos == std::string::npos) {
+                        return {"", ""};
+                    }
+                    
+                    std::string key = inner.substr(0, comma_pos);
+                    std::string value = inner.substr(comma_pos + 1);
+                    auto trim = [](std::string& s) {
+                        s.erase(0, s.find_first_not_of(" \t"));
+                        s.erase(s.find_last_not_of(" \t") + 1);
+                    };
+                    
+                    trim(key);
+                    trim(value);
+                    
+                    return {key, value};
+                };
+                
+                auto [exp_key, exp_val] = extract_map_types(expected_type);
+                auto [act_key, act_val] = extract_map_types(actual_type);
+                return types_compatible(exp_key, act_key) && 
+                    types_compatible(exp_val, act_val);
+            }
+            std::string lookup_type = expected_type;
+            auto ut_it = user_types.find(lookup_type);
+            if (ut_it == user_types.end()) {
+                size_t last_colon = lookup_type.rfind("::");
+                if (last_colon == std::string::npos && !namespaceStack.empty()) {
+                    std::string qualified;
+                    for (auto& ns : namespaceStack) {
+                        if (!qualified.empty()) qualified += "::";
+                        qualified += ns;
+                    }
+                    lookup_type = qualified + "::" + expected_type;
+                    ut_it = user_types.find(lookup_type);
+                }
+            }
+            if (ut_it == user_types.end()) {
+                for (auto& [type_name, info] : user_types) {
+                    if (type_name == expected_type ||
+                        type_name.rfind("::" + expected_type) != std::string::npos) {
+                        ut_it = user_types.find(type_name);
+                        break;
+                    }
+                }
+            }
+            if (ut_it != user_types.end() && ut_it->second.kind == UserTypeKind::Union) {
+                for (auto& m : ut_it->second.members) {
+                    std::string member_base = m.type;
+                    size_t colon_pos = member_base.find(':');
+                    if (colon_pos != std::string::npos) {
+                        member_base = member_base.substr(0, colon_pos);
+                    }
+                    if (types_compatible(member_base, actual_type)) {
+                        return true;
+                    }
+                }
+            }
+            auto actual_it = user_types.find(actual_type);
+            if (actual_it != user_types.end() && 
+                actual_it->second.kind == UserTypeKind::Class) {
+                
+                std::string base = actual_it->second.baseClassName;
+                while (!base.empty()) {
+                    if (base == expected_type) {
+                        return true;
+                    }
+                    
+                    auto base_it = user_types.find(base);
+                    if (base_it == user_types.end() || 
+                        base_it->second.kind != UserTypeKind::Class) {
+                        break;
+                    }
+                    base = base_it->second.baseClassName;
+                }
             }
             
-            auto it = functions.find(qualify(name));
-            if (it != functions.end()) return it->second;
-            return nullptr;
+            return false;
         }
         std::string get_type_name(const NumberVariant& val) {
             return std::visit([](auto&& arg) -> std::string {
@@ -1695,6 +1924,7 @@ namespace tkz {
         NumberVariant process(AnyNode& node);
         NumberVariant operator()(NumberNode& node);
         NumberVariant call_instance_method(const std::shared_ptr<InstanceValue>& inst, ClassMethodInfo* method, std::vector<NumberVariant> args, const Position& pos);
+        ClassMethodInfo* find_method_on_class(const std::string& className,const std::string& mname) ;
         NumberVariant operator()(std::unique_ptr<BinOpNode>& node);
         NumberVariant operator()(std::unique_ptr<UnaryOpNode>& node);
         NumberVariant operator()(std::monostate);
@@ -1717,7 +1947,7 @@ namespace tkz {
         NumberVariant operator()(std::unique_ptr<QOutExprNode>& node);
         bool is_truthy(const NumberVariant& val);
         std::unordered_map<std::string, NumberVariant> make_instance_fields(const std::string& className);
-        ClassMethodInfo* find_method_on_class(const std::string& className, const std::string& mname);
+        ClassMethodInfo* find_method_overload_on_class(const std::string& className, const std::string& mname, const std::vector<NumberVariant>& args);
         bool field_exists_on_class(const std::string& className, const std::string& fieldName);
         bool in_class_or_derived_context(const std::string& baseName);
         NumberVariant operator()(std::unique_ptr<AssignExprNode>& node);
